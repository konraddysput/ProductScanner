\section{Środowisko programistyczne}
W celu realizacji poszczególnych założeń projektowych został wykonany złożony program przy użyciu środowisk uruchomieniowych: 
\begin{itemize}[noitemsep]
	\item .NET Core w wersji 2.1 przy użyciu języka w C\# w wersji 7,
	\item JVM przy użyciu języka Java w wersji 8,
	\item Python w wersji 3.7,
	\item NodeJS w wersji 8,
	\item Cordova poprzez wykorzystanie biblioteki Ionic.
\end{itemize}
W tym celu skorzystano ze środowisk programistycznych: Visual Studio, IntelliJ, Pycharm oraz Visual Studio Code. W celu przygotowania aplikacji wykorzystano system operacyjny Windows 10.

Aplikacja mobilna korzysta z widoków stworzonych przy pomocy języków: TypeScript, JavaScript, SCSS oraz HTML. Za tworzenie skrytpu wynikowego interpretowanego przez urządzenie mobilne odpowiedzialna jest biblioteka webpack. Do jej uruchomienia niezbedne jest skorzystanie z konsoli, aby wywołać polecenie kompilacji. Dodatkowo jej działanie umożliwia diagnozowanie błędów aplikacji poprzez mapowanie wykonywanej linii kodu języka JavaScript na jej odpowiednik w TypeScript. Wersja produkcyjna aplikacji umożliwia skorzystanie z okrojonej wersji skrytpów oraz styli. Jest to możliwe dzięki mechanizmowi minifikacji.

Aplikacja wymaga posiadania na komputerze zainstalowanego silnika bazodanowego MS SQL Server lub jego uruchomienie poprzez użycie plików Docker. System zakłada komunikację przy wykorzystaniu kolejki. W tym celu wymagany jest dostęp do oprogramowania RabbitMQ. Pomocnymi narzędziami używanymi do analizowania pracy programu jest program rozszerzenie Postman\cite{Postman} do przeglądarki internetowej Google Chrome lub pakiet Fiddler\cite{Fiddler}. Dzięki nim programista może wysłać żadanie do serwera na odpowiedni adres URL z określonymi danymi. Mikroserwisy zostały stworzone jako aplikacje konsolowe, które nasłuchują na przychodzące żądania. W przypadku serwera www, konieczne jest jego uruchomienie przy pomocy serwera proxy Nginx lub IIS.


\section{Biblioteki}

W celu stworzenia systemu skorzystano z szerokiego zakresu bibliotek. Dodano je przy pomocy menadżerów paczek dla poszczególnych języków:
\begin{itemize}[noitemsep]
	\item npm dla środowiska uruchomieniowego NodeJS oraz JavaScript,
	\item Maven dla mikroserwisu stworzonego za pomocą języka Java,
	\item PIP oraz Anaconda dla mikroserwisu przetwarzania obrazu w środowisku Python,
	\item Nuget dla aplikacji internetowej w ASP.NET Core.
\end{itemize}

Zbiór bibliotek użytych w każdym z projektów znajduje się w plikach interpretowanych przez mandżerów paczek (np. package.json). W przypadku aplikacji dotyczącej przetwarzania obrazu, niezbędne pakiety instalacyjne znajdują się pliku README.md. Zbiór najważniejszych bibliotek oraz ich przeznaczenie znajduje się w tabelach \ref{librariesDotNet}, \ref{librariesMobile}, \ref{librariesPython} oraz \ref{librariesJava}. Każda z nich przedstawia wykorzystane paczki w poszczególnych projektach. Rozbicie na tabeli ułatwi zrozumienie ich użycia w przygotowaniu aplikacji .

\begin{center}
    \begin{longtable}{ | p{3.1cm} | p{4cm} | p{6.5cm} |}
   	\caption{Zbiór wykorzystanych bibliotek w aplikacji internetowej}
   	\label{librariesDotNet} \\
    %header
    \hline Nazwa \newline Biblioteki & Cel & Opis \\ \hline    
    %header
    
    \hline AspNetCore &
   			 Stworzenie aplikacji internetowej
   		
    & Biblioteka niezbędna do stworzenia aplikacji w stukturze ASP.NET Core. Umożliwia ona stworzenie całego ekosystemu aplikacji internetowej oraz struktur pomocniczych, które umożliwią np. przetwarzanie żądań HTTP. Dzięki niej stworzona aplikacja konsolowa wywołuje odpowiednie metody w kontrolerze w zalezności od zapytania wysłanego na odpowiedni adres url.\\ \hline
    
    \hline 
    Aurofac 
    & Tworzenie obiektów według wzorca odwróconego sterowania
    & Biblioteka umożliwiająca wstrzykiwanie struktur danych. Aplikacja w ASP.NET Core zawierają mechanizmu odwróconego sterowania. W przypadku projektu mikroserwisów stworzono własny mechanizm wywoływania odpowiednich metod w zależności od otrzymanych zdarzeń. Domyślne mechanizmy w tym przypadku sprawiały problemy z implementacją.\\ \hline
    
    \hline Entity \newline Framework
    & Dostep do danych
    &  Biblioteka umożliwiająca operacje na danych bazodanowych. Wykorzystanie jej umożliwiło odczyt, edycje, usuwanie oraz zapisywanie danyc w bazie danych. Dzięki niej stworzono również podstawowy szkielet tablet.
    \\ \hline
    
    \hline Microsoft \newline Identity 
    & Zabezpieczenie \newline aplikacji
   	& Biblioteka pozwalająca stworzenie struktur bazodanowych, które będą przechowywały dane dotyczace użytkowników w ramach danej sesji. Zawiera ona dużą liczbę pomocnych metod uwierzytelniania, autoryzacji oraz bezpieczeństwa. \\ \hline
    
    \hline SignalR 
    & Komunikacja w czasie rzeczywistym
    & Biblioteka umożliwiająca komunikację w czasie rzeczywistym z dowolnym klientem uruchomionym w przeglądarce użytkownika. Dzięki niej informujemy użytkownika o skończeniu przetwarzania danych przez mikroserwisy oraz wyłączamy ekran oczekiwania na dane.\\ \hline
    
    \hline Newtonsoft Json.NET  
    & Serializacja oraz deserializacja danych
    & Biblioteka umożliwiająca serializację oraz deserializację obiektów aplikacji.\\ \hline
    
    \hline JWT
     & Mechanizm autoryzacji i uwierzytelnienia
    & JWT umożliwia tworzenie tokenów z informacjami na temat użytkownika zaraz po jego zalogowaniu. Dzięki dołączaniu wygenerowanej wartości do żądań aplikacja internetowa wie o tym, który użytkownik przesyła dane.\\ \hline
    
     \hline RabbitMQ Client
    & Wysyłanie \newline wiadomości do \newline mikroserwisów przy użyciu RabbitMQ
    & Klient oprogramowania RabbitMQ umożliwia tworzenie kolejek wiadomości oraz kanałów komunikacyjnych. Dzięki niemu aplikacja internetowa wysyła dane w zserializowanej formie do mikroserwisów. Klient umożliwia odbieranie danych poprzez zastosowanie zdarzeń. W tej sposób rejestrowane są odpowiedzi mikroserwisów.\\ \hline
    
     \hline Polly
    & Zasady ponownego rozesłania wiadomości
    & Polly umożliwia zdefiniowanie zasad ponownej wysłanie wiadomości na kolejkę. W przypadku gdy żaden z klientów RabbitMQ nie odbierze wiadomości, wówczas możliwe jest ponowne wysłanie wiadomości. Aplikacja wykorzystuja zdefiniowane zasady podczas braku połaczenia z oprogramowaniem RabbitMQ.\\ \hline
    
	\end{longtable}
\end{center}

W tabeli nie została opisana żadna biblioteka, która generuje widoki przy użyciu mechanizmów ASP.NET Core. Ze względu na charakterystykę aplikacji oraz wykorzystanie architektury REST, użycie tego typu narzędzi było zbędne. Biblioteki zostały zainstalowane za pomocą narzędzie Nuget w Visual Studio 2017, a informacje o nich przechowywane są w plikach .csproj każdego podmodułu. Aplikacja zakłada automatyczne pobranie bibliotek w przypadku gdy nie znajdują się w katalogu solucji. Wszystkie wybrane biblioteki są zgodne z aplikacjami .NET Core. Oznacza to możliwość uruchomienia oprogramowania na systemach operacyjnych wspieranych przez .NET Core 2.1 - Linux, Windows, MacOS.

\begin{center}
	\begin{longtable}{ | p{1.7cm} | p{2cm} | p{3.5cm} | p{6cm} |}
		\caption{Zbiór wykorzystanych bibliotek w aplikacji mobilnej}
		\label{librariesMobile} \\
		%header
		\hline Nazwa & Typ  & Cel & Opis \\ \hline    
		%header
		
  		\hline Angular 5
  		& Biblioteka JavaScript
		& Tworzenie widoków aplikacji
		& Biblioteka umożliwia generowanie widoków na podstawie stworzonych szablonów oraz aktualnego stanu zmiennych. Składa się on z wielu modułów, które razem tworzą dojrzały ekosystem. Jest to jedna z najpopularniejszych bibliotek do tworzenia interfejsów użytkownika.\\ \hline
	
		\hline Cordova
		& Szkielet aplikacji
		& Stworzenie \newline aplikacji mobilnej
		& Apache Cordova umożliwia tworzenie hybrydowych aplikacji na platformy mobilne. Tworzy interfejs komunikacyjny pomiędzy widokami w postaci strony www, a urządzeniami peryferyjnymi telefonu.\\ \hline
		
		\hline Ionic 3
		& Szkielet aplikacji
		& Stworzenie \newline aplikacji mobilnej
		& Ionic obudowuje szkielet aplikacji Cordova w metody oraz funkcje przyspieszajace prace programisty nad systemami mobilnymi. Zapewnia on składnie tworzenia widoków, komunikację z urządzeniami peryferyjnymi oraz integrację z narzędziami do wytwarzania oprogramowania.\\ \hline
		
		\hline Webpack
		& Budowa aplikacji
		& Tworzenie wynikowych plików JavaScript oraz CSS
		& Przeglądarka nie jest w stanie zinterpretować kodu stworzonego przy użyciu języka TypeScript lub SCSS. Webpack jest narzędziem umożliwiającym translację kodu napisanego w wyżej wymienionych językach na pliki wynikowe JavaScript oraz CSS. \\ \hline
	
		\hline ASP.NET SignalR klient
		& Biblioteka JavaScript
		& Komunikacja w czasie rzeczywistym
		& W celu odbierania informacji w czasie rzeczywistym z aplikacji internetowej niezbędne jest dołączenie biblioteki ASP.NET SignalR. Zapewnia ona zbiór metod pozwalających na rejestrację klienta w aplikacji oraz swobodną wymianę informacji przy użyciu gniazdek internetowych. \\ \hline
	
		\hline Cordova Plugin Camera
		& Wtyczka do kamery
		& Komunikacja pomiędzy aplikacją a kamerą
		& Użytkownik aplikacji może wysłać zdjęcie bezpośrednio z kamery. Oznacza to konieczność integracji z urządzeniem peryferyjym. Zostało to zrealizowane dzięki użyciu wtyczki cordova-plugin-camera, która umożliwia przechwycenie obrazu z kamery oraz zapisanie go w aplikacji. Ponadto wtyczka dostarcza metody integracji z galerią zdjęć.\\ \hline
	\end{longtable}
\end{center}

Aplikacja mobilna została stworzona przy użyciu języku TypeScript. Zostało w tym celu użyte środowisko Visual Studio Code oraz narzędzie webpack, która umożliwia transpilacje do plików wynikowych CSS oraz JavaScript. Wszystkie niezbędne biblioteki do uruchomienia aplikacji mobilnej znajdują się w pliku package.json. Aby kod mógł zostać uruchomiony na urządzeniu mobilnym, niezbędne jest dostarczenie dodatkowych jego zależności takich jak Android-SDK. Konieczne do zainstalowania zależności są uwarunkowane docelową platformą mobilną. Wymogiem niezbędnym do komunikacji pomiędzy serwerem, a urządzeniem mobilnym jest połączenie aplikacji internetowej oraz mobilnej do tej samej sieci. W przypadku wdrożenia produkcyjnego oraz użycie aplikacji internetowej w Internecie, nie ma potrzeby użycia tej samej siecii WiFi.


\begin{center}
	\begin{longtable}{ | p{3.1cm} | p{4cm} | p{6.5cm} |}
		\caption{Zbiór wykorzystanych bibliotek w mikroserwisie przetwarzania obrazu}
		\label{librariesPython} \\
		%header
		\hline Nazwa \newline Biblioteki & Cel & Opis \\ \hline    
		%header
		
		\hline Tensorflow 1.8 &
		Detekcja przedmiotów na obrazie
		
		& Biblioteka użyta do detekcji przedmiotów znajdujacych się na obrazie, znajdujących się w bazie wiedzy. Dane otrzymane w wyniku działania metod Tensorflow zostały użyte do wnioskowania przeprowadzonego w mikroserwisie reguł semantycznych.\\ \hline


	\hline opencv-python &
	Stworzenie modelu
	
	& Biblioteka użyta do stworzenia plików nazywanych TFRecords. Stanowią one dane wejściowe dla metod biblioteki Tensorflow służących do nauczenia modelu oblizceniowego detekcji przedmiotów.\\ \hline	
	
	\hline pandas &
	Stworzenie modelu
	
	& Biblioteka użyta do stworzenia plików nazywanych TFRecords.\\ \hline	
	
	\hline pika &
	Komunikacja z \newline RabbitMQ
	
	& Klient oprogramowania RabbitMQ. Biblioteka służąca do stworzenia kanału komunikacyjnego oraz odbierania/wysyłania wiadomości do innych mikroserwisów.\\ \hline	
	
	\end{longtable}
\end{center}

W celu uruchomienia mikroserwisu należy zainstalować zbiór bibliotek niezbędny do przetwarzania oraz analizy obrazu. Najważniejsze z nich zostały przedstawione w tabeli \ref{librariesPython}, lecz używane zależności zostały w tym przypadku pominięte. Biblioteka Tensorflow do poprawnego działania wymaga również instalacji: pillow, lxml, Cython, matplotlib, pandas oraz opencv-python. Aby stworzyć model, niezbędny do uzyskania wynikow z programu skorzystano z narzędzia LabelImg, które jest otwartym oprogramowaniem, dostępnym do ściągnięcia na serwisie Github. Przedmiot, który znajduje się na zdjęciu testowym, należy opisać w sposób zrozumiały do załączonych biblioetk. Dzięki narzędziu możliwe jest łatwe oznaczanie przedmiotu na zdjęcia oraz jego opis. 

Mikroserwis nie komunikuje się bezpośrednio z serwisem reguł semantycznym. Wynik przetwarzania obrazu przesyłany jest do aplikacji Internetowej. Otrzymanie wyjątku lub pusty wynik mikroserwisu nie spowoduje wywołania serwisu reguł semantycznych. W innym przypadku aplikacja internetowa przekaże dane do przetwarzania przez reguły semantyczne. 


\begin{center}
	\begin{longtable}{ | p{3.1cm} | p{4cm} | p{6.5cm} |}
		\caption{Zbiór wykorzystanych bibliotek w mikroserwisie reguł semantycznych}
		\label{librariesJava} \\
		%header
		\hline Nazwa \newline Biblioteki & Cel & Opis \\ \hline    
		%header
		
		\hline Apache Jena &
		Przetwarzanie reguł semantycznych
		
		& Jena jest biblioteką umożliwiającą tworzenie siecii semantycznych oraz budowanie relacji pomiedzy danymi. Została wykorzystana w celu przetwarzania istniejącej ontologii. \\ \hline
		
		\hline Jackson &
		Serializacja oraz deserializacja JSON
		
		& Biblioteka została użyta w celu dokonywania serializacji istniejących obiektów programu na format JSON oraz deserializacji, czyli zamiany tekstu na instancje klasy.\\ \hline
		
		\hline rabbitmq &
		Klient RabbitMQ
	
		& Klient oprogramowania RabbitMQ. Służy do komunikacji przy użyciu wiadomości wysyłanych do kolejek danych. Klient umożliwia komunikację z aplikacją internetową.\\ \hline

	\end{longtable}
\end{center}

Mikroserwis reguł semantycznych wykorzystują istniejącą ontologię, stworzoną przy użyciu oprogramowania Protege \cite{Protege}. Oprogramowanie zakłada istnienie ontologii przed uruchomieniem aplikacji. W ramach mikroserwisu zostały wykonane dwa serwisy, które służą za komunikację z kolejką danych oraz uruchamianie metod semantycznych. Przetwarzanie ontologii odbywa się z wykorzystaniem biblioteki Jena. Uzyskany wynik umożliwia poznanie informacji na temat przetwarzanego przedmiotu. Reguły zawarte w ontologii wskazują niepoprawności, które zachodzą pomiędzy obiektami poddawanymi analizie. Rezultat serwisu metod semantycznych powoduje wysłanie przez mikroserwis danych do aplikacji internetowej o klasyfikowanym przedmiocie oraz o regułach jego przynależności. 
Wszystkie z wymienionych bibliotek zostały zainstalowane przy pomocy menadżera paczek - Maven. Definicje niezbędnych do uruchomienia paczek znajdują się w pliku projektowym o nazwie pom.xml. Uruchomienie mikroserwisu spowoduje automatyczne pobranie zależności.


\section{Uruchomienie}

Stworzony system zakłada konieczność integracji wielu środowisk uruchomieniowych, języków oprogramowania oraz sposobów komunikacji. Użytkownik poznaje informacje na temat przedmiotów znajdujących na zdjęciu poprzez analize danych otrzymanych z mikroserwisu przetwarzania obrazu oraz reguł semantycznych. Uruchomienie ostatniego jest zależne od wyniku otrzymanego metod klasyfikacji przedmiotów na zdjęciu. 

Programista pobierając repozytorium z kodem posiada część informacji niezbędnych do uruchomienia i pomyślnego przetwarzania obrazu. Jest to spowodowane dużą ilością wygenerowanych plików oraz ich rozmiarem. Dobre praktyki wskazują, aby takie pliki nie były umieszczane na repozytorium kodu. Sam projekt został stworzony na podstawie istniejącego przykładu dostarczonego wraz z biblioteką Tensorflow. 

W celu uruchomienia mikroserwisu należy zainstalować wszystkie biblioteki wymienione w tabeli \ref{librariesPython} przy użyciu polecenia pip lub conda. Komendy należy uruchomić przy użyciu konsoli - na przykład CMD lub Powershell\cite{Powershell} w Systemie Windows 10. Biblioteki wykorzystują dane znajdujące się w zmiennej systemowej PYTHONPATH. W tym celu należy dodać ścieżkę do katalogu models, research oraz slim (znajdującego sie w folderze research). Wyjście z wirtualnego środowiska środowiska Python może spowodować wyczyszczenie zmiennych środowiskowych. Aktywacje wirtualnego środowiska anacondy, instalację bibliotek oraz eksport zmiennych środowiskowych została przedstawiona w listingu \ref{terminalConfiguration}. Kolejne wiersze konsoli zostały oddzielone przy użyciu znaku \$.


\begin{lstlisting}[caption={Instalacja bibliotek.}, label={terminalConfiguration} ]
$ activate dev
$ conda install -c anaconda protobuf
$ pip install Cython pillow lxml matplotlib pandas opencv-python
$ set PYTHONPATH=C:\tensorflow\models;
	C:\tensotflow\models\research;
	C:\tensorflow\models\research\slim
\end{lstlisting}

Programiści, którzy chcą uruchomić bibliotekę korzystając z kodu źródłowego dołączonego wraz z biblioteką Tensorflow, dodatkowo muszą wykonać budowe plików Protobuf. Aby tego dokonać należy wykonać komendę protoc w folderze research katalogu modles z parametrami określającymi ścieżki docelowe wygenerowanych plików ".proto". Zbudowane pliki dołączone wraz z biblioteką mogę generować ewentualne błędy na różnych dystrybucjach oprogramowania lub systemach operacyjnych. Listing \ref{protobufInstallation} przedstawia przykładowe wygenerowanie plików ".proto".

\begin{lstlisting}[caption={generowanie plików protobuf.}, label={protobufInstallation} ]
$ cd C:\tensorflow\models\research
$ protoc --python_out=. 
	.\object_detection\protos\anchor_generator.proto ....
$ python setup.py build
$ python setup.py install
\end{lstlisting}

Wygenerowanie plików protobuf jest ostatnim krokiem niezbędnym do rozpoczęcia nauki modelu klasyfikacji przedmiotów na obrazie. W celu stworzenia niezbędnych danych opisujących obiekty na zdjęciach użyto narzędzia LabelImg, które jest projektem ogólnodostępnym na publicznym repozytorium Github. W celu wyuczenia modelu sklasyfikowano opisano przedmioty zdajdujące się na zdjeciach z katalogu images. Wymagało to dla każdego obrazu zaznaczenia prostokątem pozycji przedmiotu oraz jego klasyfikacji - na przykład puszka pepsi. Dane wejściowe zostały podzielone na dwa zbiory. Pierwszy znich zawiera zdjęcia które posłużą do nauki modelu. W drugim znajdują się obrazki testujące przetworzony model. W trakcie przetwarzania zdjęć natrafiono na problem wysokiej rozdzielczości aparatu. Zauważono, że im wyższa jakość zdjęcia tym dłuższy czas przetwarzania modelu. W tym celu zastosowano skrypt pogarszający jakość zdjęć, a tym samym jego wielkość. 

Przygotowanie zdjęć do procesu nauki modelu jest bardzo istotnym elementem konfiguracji. W zależności od przygotowanych obrazów oraz dokładności ich opisu algorytm uczenia maszynowego stworzy mniej lub bardziej dokładny model. W przypadku zaawansowanych rozwiązań stopień pewności rozwiązania na poziomie 95\% możę wydawać się dużym sukcesem. Łatwo wyobrazić sobie system, który poprzez pomyłkę może doprowadzić do szkody lub wygenerowania niepoprawnych danych. Przed uruchomieniem algorytmu uczenia programista musi wygenerować TFRecords, czyli konkatencja plików XML z informacjami na temat wskazanego przedmiotów na zdjeciach do pliku CSV.W tym celu użyto skryptu, nazywającego się xml\_to\_csv.py. Jego wynikiem będzie utworzenie plików zawierające dane testowe oraz treningowe w formacie CSV. Ostatnim elementem niezbędnym do poprawnego interpretowania wyników uczenia maszynowego jest mapowanie klasyfikatorów algorytmu w postaci tekstu na klasyfikatory w postaci liczb. W tym celu należy edytować pliki generate\_tfrecord.py oraz labelmap z katalogu training i dostosować strukturę klasyfikowanych plików do do klasyfikatorów ze zdjeć. Aby rozpocząć naukę modelu zastosowano skrypt z listingu \ref{machineLearning}. W przypadku nauki modelu używanego w oprogramowaniu, algorytm przetwarzał dane około 2 godziny. 

\begin{lstlisting}[caption={Uruchomienie algorytmu uczenia maszynowego.}, label={machineLearning} ]
$ python train.py 
	--logtostderr 
	--train_dir=training/
	 --pipeline_config_path=
	 	training/faster_rcnn_inception_v2_productscanner.config
\end{lstlisting}


Stworzenie modelu jest czynnością opcjonalną. Repozytorium projektu zawiera już wygenerowane pliki w odpowiednich katalogach projektowych. Zostały przedstawione czynności, które programista może podjać aby ewentualnie rozszerzyć projekt o dodatkowe modele. Niezbędne w tym przypadku jest uruchomienie serwera bazodanowego oraz systemu kolejkowego RabbitMQ. W tym celu na rzecz wytwarzania oprogramowania przygotowano pliki Docker. Zawierają one definicję niezbędnych kontenerów z oprogramowaniem, które mogą zostać uruchomione bez konieczności instalacji ich na stacji roboczej. W tym celu należy za pomocą oprogramowania docker oraz konsoli Powershell wykonaj polecenie:

\begin{lstlisting}[caption={Uruchomienie kontenerów docker.} ]
$ cd ./src/ProductScanner.Backend/
$ docker-compose up -f ./docker-compose-dev.yml up -d
\end{lstlisting}

Uruchomienie kontenerów nie jest wymagane. Przygotowując środowisko programistyczne, należy jednak pamietać o konieczności korzystania z bazy danych MS SQL Server oraz RabbitMQ. Wykorzystanie Dockera w tym przypadku nie wymaga instalacji serwera bazodanowego oraz kolejki wiadomośći, co w znaczący sposób może przyspieszyć uruchomienie aplikacji lub wprowadzenie drobnych poprawek. Dobrą praktyką jest każdorazowe wyłączenie uruchomionych kontenerów poprzez zastosowanie polecenia przedstawionego w listingu \ref{dockerDown}, ze względu na integrację danych znajdujących się w kontenerach. 


\begin{lstlisting}[caption={Komenda docker-compose down.},label={dockerDown} ]
$ cd ./src/ProductScanner.Backend/
$ docker-compose -f ./docker-compose-dev.yml down
\end{lstlisting}


\section{Konfiguracja}

Aplikacja internetowa ze względu na charakter jaki pełni w oprogramowaniu musi zapewnić interfejs komunikacji HTTP oraz możliwość rozsyłania wiadomośći do pozostałych mikroserwisów. Ponadto konfiguracja zakłada możliwość komunikacji z urządzeniami zewnętrznymi, co wymusza wsparcie dla CORS. Aplikacja internetowa zakłada istnienie bazy danych oraz oraz jej konfiguracji. Wszystkie wymienione założenia sprawiają konieczność zaawansowanej konfiguracji aplikacji. W tym celu w projektach ASP.NET Core dokonano zaawansowen konfiguracji klasy Startup.cs. W metodzie ConfigueServices stworzon kod, który inicjalizuje struktury bazodanowe, który został przedstawiony w listingu \ref{databaseConfiguration}. 

\begin{lstlisting}[caption={Konfiguracja bazy danych oraz obiektu komunikacji bazodanowej.},label={databaseConfiguration} ]
string connectionString = 
	Configuration["ConnectionStrings:DbContextConnection"];
	
services.AddDbContext<ProductScannerDbContext>(options =>
	options
	.UseLazyLoadingProxies()
	.UseSqlServer(connectionString));

services.AddDefaultIdentity<ApplicationUser>(options =>
{
	options.Password.RequireDigit = false;
	options.Password.RequiredLength = 3;
	options.Password.RequireNonAlphanumeric = false;
	options.Password.RequireUppercase = false;
	options.Password.RequireLowercase = false;
})
.AddEntityFrameworkStores<ProductScannerDbContext>()
.AddDefaultTokenProviders();
\end{lstlisting}


Dalsza implementacji metody zakłada stworzenie obiektów odwróconego sterowania (Dependency Injection) oraz konfigurację między innymi autoryzacji lub komunikacji w czasie rzeczywistej. Dane niezbędne do skonfigurowania poszczególnych obiektów - na przykład parametrów autoryzacji, zostały wczytane z pliku appsettings.json. Plik ten znajduje się w folderze domowym aplikacji internetowej. Poza konfiguracją zabezpieczeń aplikacji, znajdują się w nim między innymi parametry połączenia z bazą danych, oprogramowaniem RabbitMQ oraz ustawienia poziomu logowania. Użycie pliku konfiguracyjnego jest dobrą praktyką pomocną przy dokonywaniu wdrożeń. Umożliwia ona między innymi dostosowanie aplikacji bez jej dodatkowej rekompilacji. Kod przedstawiający konfigurację serwisów oraz autoryzacji został przedstawiony w listingu \ref{dependencyInjectionAndConfiguration}. 

\begin{lstlisting}[caption={Stworzenie obiektów odwróconego sterowania.},label={dependencyInjectionAndConfiguration} ]
services.AddCors();
services.AddServices();
services.AddRepositories();
services.RegisterEventBus(Configuration);

services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
.AddJwtBearer(options =>
{
	options.TokenValidationParameters = new TokenValidationParameters
	{
		ValidateIssuer = true,
		ValidateAudience = true,
		ValidateLifetime = true,
		ValidateIssuerSigningKey = true,
		ValidIssuer = Configuration["Jwt:Issuer"],
		ValidAudience = Configuration["Jwt:Issuer"],
		IssuerSigningKey = new SymmetricSecurityKey(
			Encoding.UTF8.GetBytes(Configuration["Jwt:Key"]))
	};
});

services.AddMvc(options =>
{
	options.Filters.Add(typeof(HttpGlobalExceptionFilter));
	options.Filters.Add(typeof(ValidateModelStateFilter));
})
.SetCompatibilityVersion(CompatibilityVersion.Version\_2\_1);

services.AddSignalR();
services.AddMapperConfiguration();
var container = new ContainerBuilder();
container.Populate(services);

return new AutofacServiceProvider(container.Build());
\end{lstlisting}

Niektóre z metod wykonywanych na obiekcie services stanowią metody rozszerzeń stworzone na obiekcie ServiceProvider. Do ich grona należą metody:
\begin{itemize}[noitemsep]
	\item AddRepositories(), której celem jest dodanie wszystkich istniejących repozytoriów dostępów do danych.
	\item AddServices, która zawiera wszystkie serwisy przechowujące logikę biznesową aplikacji,
	\item RegisterEventBus(Configuration), która tworzy połączenie z oprogramowaniem RabbitMQ oraz rejestruje obiekt umożliwiający wysyłanie wiadomości do mikroserwisów,
	\item AddMapperConfiguration(), ktora inicjalizuje bibliotekę Automapper wraz ze wszystkimi profilami mapowania.
\end{itemize}


\begin{lstlisting}[caption={Metoda rozszerzeń umożliwiająca dodanie serwisów do mechanizmów odwróconego sterowania.} ]
public static class ServiceConfiguration
{
	public static IServiceCollection AddServices
		(this IServiceCollection services)
	{
		services.AddScoped<IJwtService, JwtService>();
		services.AddScoped<IPhotoService, PhotoService>();
		services.AddScoped<IPhotoObjectService, PhotoObjectService>();
		return services;
	}
}
\end{lstlisting}

Metoda AddMvc, która ma za zadanie wywoływanie odpowiednich kontrolerów w zależności od żądań HTTP, dodatkowo dodaje dwa filtry. Zostały one dodane w celu stworzenia generycznych odpowiedzi w przypadku napotkania błędu oraz dokonywania modelu wejściowego. W tym celu aby stworzyć filtr, który będzie wywoływany przed lub po przetworzeniu żądania HTTP należało stworzyć klasę dziedziczącej z ActionFilterAttribute. Stworzony filtr powinien nadpisywać jedną z metod dostępnych w klasie bazowej, aby był on egzekwowany przy przetwarzaniu żądań HTTP. Przykładowy filtr umożliwiający walidację danych znajduje się w listingu poniżej.

\begin{lstlisting}[caption={Stworzenie obiektów odwróconego sterowania.},label={dependencyInjectionAndConfiguration} ]
 public class ValidateModelStateFilter : ActionFilterAttribute
{
	public override void OnActionExecuting
		(ActionExecutingContext context)
	{
		if (context.ModelState.IsValid) return;		
		var validationErrors = context.ModelState
			.Keys.SelectMany(k => context.ModelState[k].Errors)
			.Select(e => e.ErrorMessage).FirstOrDefault();		
		context.Result = new BadRequestObjectResult(validationErrors);
	}
}
\end{lstlisting}

Aplikacja internetowa w celu komunikacji z innymi mikroserwisami używa oprogramowania RabbitMQ. Za jego pomocą rozsyła wiadomości przy użyciu klucza routingu, do agentów nasłuchujących w kolejce. Metoda RegisterEventBus(Configuration) dodana do serwisów w konfiguracji aplikacji dodaje klienta RabbitMQ do aplikacji. Jego metoda inicjalizująca zakłada dodanie zdarzeń w przypadku otrzymania danych oraz zablokowania lub zamknięcia połączenia. W przypadku komunikacji przy użyciu kolejki możemy oczekiwać, że aktualnie mikroserwis do którego chcemy wysłać wiadomość może być niedostępny. Mogłoby to być spowodowane zbyt dużym obciążeniem lub chwilową niedostępnością serwera. W związku z tym konfiguracja klienta RabbitMQ zakłada polityki bezpieczeństwa w przypadku napotkania błędów. Dzięki temu, po upływie okreslonego czasu oprogramowanie wznowi połączenia z kolejką lub wyśle ponownie wiadomość do niedostępnego wcześniej mikroserwisu.


\begin{lstlisting}[caption={Metoda połączenia klienta RabbitMQ.} ]
lock (sync_root)
{
	RetryPolicy policy = RetryPolicy.Handle<SocketException>()
	.Or<BrokerUnreachableException>()
	.WaitAndRetry(_retryCount, retryAttempt => 
		TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), 
		(ex, time) => {
		_logger.LogWarning(ex.ToString());
	});
	
	policy.Execute(() =>
	{
		_connection = _connectionFactory
		.CreateConnection();
	});
	
	if (IsConnected)
	{
		_connection.ConnectionShutdown += OnConnectionShutdown;
		_connection.CallbackException += OnCallbackException;
		_connection.ConnectionBlocked += OnConnectionBlocked;
		
		_logger.LogInformation(\$"Connected");		
		return true;
	}
	_logger.LogCritical("RabbitMQ connections could not be created");	
	return false;
}

\end{lstlisting}

Klient RabbitMQ został stworzony dodatkowo w mikroserwisach przetwarzania obrazu oraz reguł semantycznych. W przypadku środowiska uruchomieniowego python, egzekwowane są wiadomości, które są wysyłane z kluczem routingu "ImageClasificationEvent". W tym celu użyto biblioteki pika. Parametry połączenia oraz zmienne konfiguracyjne klienta RabbitMQ zostały umieszczone w stałych klasy Communication.

\begin{lstlisting}[caption={Klient RabbitMQ dla mikroserwisu przetwarzania obrazu.}]
class Communication:
	objectDetection = None
	
	exchange_type = 'direct'
	credentials = pika.PlainCredentials('node', 'node')
	conn_param = pika.ConnectionParameters('localhost',credentials)
	connection = pika.BlockingConnection(conn_param)

	channel = connection.channel()
	queue_name = 'scanner-api-python'
	receive_routing_key = 'ImageClasificationEvent'
	send_routing_key = 'ImageClasificationResultEvent'
	exchange_name = 'product-scanner-event-bus'
	
	def __init__(self):
		self.objectDetection = ObjectDetection()
		self.channel.exchange_declare(
			exchange=self.exchange_name,
			exchange_type=self.exchange_type)
		self.connect()
	
	def connect(self):
		self.channel.queue_declare(self.queue_name, False)
		self.channel.queue_bind(exchange=self.exchange_name,
									queue=self.queue_name,
									routing_key=self.receive_routing_key)
	
		print('[*] Waiting for logs. To exit press CTRL+C')
	
		self.channel.basic_consume(self.callback,
			queue=self.queue_name,
			no_ack=True)

\end{lstlisting}

W przypadku mikroserwisu reguł semantycznych użyto biblioteki rabbitmq znalezionej w repozytorium bibliotek Maven. Aby jej użyć dodano definicję biblioteki do pliku pom.xml, który zawiera konfigurację wszystki zależności aplikacji. Zmienne klienta RabbitMQ tak jak w przypadku mikroserwisu przetwarzania obrazu, przechowywane są w stałych zmiennych. W celu uruchomienia mikroserwisu należy wysłać wiadomość na klucz routingu "ImagePreprocessingEvent".
\begin{lstlisting}[caption={Klient RabbitMQ dla mikroserwisu reguł semantycznych.}]
public class EventBusService {
	private  Channel _channel;
	
	private WebSemanticService _service;
	
	public  EventBusService() 
		throws TimeoutException, IOException, IllegalAccessException{
		setupExchange(getConnectionFactory());
		_service = new WebSemanticService();
	}
	
	public void listen() throws java.io.IOException{
		Consumer consumer = new DefaultConsumer(_channel){
			
			@Override
			public void handleDelivery(String consumerTag,
			 Envelope envelope, AMQP.BasicProperties properties, 
			 byte[] body) throws IOException {
			 handling algorithm
			}
		};
		_channel.basicConsume(QUEUE_NAME, true, consumer);
		System.out.println(" [*] Waiting for logs.");
	}
	
	private void setupExchange(ConnectionFactory factory) 
		throws TimeoutException, IOException{
		Connection connection = factory.newConnection();
		_channel= connection.createChannel();
		_channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
		_channel.queueDeclare(QUEUE_NAME, false, false, false, null);
		_channel.queueBind(QUEUE_NAME, 
			EXCHANGE_NAME, 
			RECEIVE_ROUTING_KEY);
	}
	
	private ConnectionFactory getConnectionFactory(){
		ConnectionFactory factory = new ConnectionFactory();
		...
		return factory;
	}
\end{lstlisting}
Aplikacja mobilna komunikuje się w serwerem ASP.NET Core przy użyciu protokołu HTTP. W tym przypadku konfiguracja szablonu projektowego Ionic ograniczyła się do wskazania stron, komponentów oraz serwisów w pliku app.module, używanego przez bibliotekę Angular 5. Strona startowa aplikacji mobilnej jest generowana w zależności od tokenu znajdującego sie w lokalnej pamięci urządzenia. Jeżeli użytkownik nie zalogował się, wówczas strona startową jest zakładka logowania i rejestracji. W innym przypadku, jeżeli token istnieje, wówczas generowany jest główny widok aplikacji.
\begin{lstlisting}[caption={Generowanie strony w zależności od tokenu znajdującego sie w pamięci urządzenia.}]

@Component({
	templateUrl: 'app.html'
})
export class MyApp {
	rootPage:any;
	
	constructor(platform: Platform, statusBar: StatusBar, 
		splashScreen: SplashScreen) {
			this.rootPage = !localStorage.getItem("token")
			? WelcomePage
			: TabsPage;
			
			platform.ready().then(() => {
				statusBar.styleDefault();
				splashScreen.hide();
			});
	}
}
\end{lstlisting}


\section{Zaimplementowane metody}
Niniejszy rozdział ma na celu przedstawienie sposobu implementacji funkcjonalności uwzględnionych w wymaganiach programu. Omawiane funkcje pokazują sposób komunikacji poszczególnych modułów oprogramowania. Metody nieomówione w dokumencie znajdują się w kodzie źródłowym aplikacji dołączonym w załączniku. W celu ich analizy należy udać się do katalogu src znajdującego się w folderze domowym projektu.
\\
\begin{itemize}
\item \textbf{Logowanie z wykorzystaniem biblioteki JWT} - Mechanizm logowania wymaga wysłania do aplikacji internetowej z urządzenia mobilnego danych użytkownika i hasła. W tym celu aplikacja ASP.NET Core wykorzystuje bibliotekę Identity oraz JWT do tego by wygenerować token autoryzacji. Żądanie otrzymane w kontrolerze zostaje przetworzone w kontrolerze. Wykorzystano w tym celu istniejący serwis w bibliotece Identity. Za pomocą którego wyszukany zostanie użytkownik o danej nazwie oraz haśle uzyskanym z funkcji skrótu. W przypadku gdy użytkownik istnieje serwis biblioteki JWT wygeneruje token autoryzacyjny. Zostały w nim umieszczone informacje o identyfikatorze, nazwie oraz rolach użytkownika w systemie.

\begin{lstlisting}[caption=Metoda generująca token JWT.]
 public string GenerateToken(ApplicationUser user)
{
	string jwtKey = _configuration["Jwt:Key"];
	byte[] keyBytes = Encoding.UTF8.GetBytes(jwtKey);
	var key = new SymmetricSecurityKey(keyBytes);
	var creds = new SigningCredentials(key, 
		SecurityAlgorithms.HmacSha256);
	var claims = new List<Claim>
	{
		new Claim(JwtRegisteredClaimNames.Sub, $"{user.Id}"),
		new Claim(JwtRegisteredClaimNames.Jti, $"{Guid.NewGuid()}"),
		new Claim(ClaimTypes.NameIdentifier, user.UserName)
	};
	string confExpTime = _configuration["Jwt:ExpirationTime"];
	int expirationTime = int.Parse(confExpTime);
	var token = new JwtSecurityToken(
		_configuration["Jwt:Issuer"],
		_configuration["Jwt:Issuer"],
		expires: DateTime.Now.AddMinutes(expirationTime),
		claims: claims,
		signingCredentials: creds);
	
	return new JwtSecurityTokenHandler().WriteToken(token);
}
\end{lstlisting} 

W celu wywołania akcji Authorize kontrolera Token, aplikacja mobilna tworzy żądanie logowania na podstawie danych uzyskanych od użytkownika. W tym celu do klasy widoku został wstrzyknięty serwis autoryzacji użytkownika - authService. Na jego instancji została wywołana metoda authenticate, która w przypadku pomyślnego wykonania żądania zapisuje w lokalnej pamięci uzyskaną odpowiedź. Wynikiem przetworzenia danych przez klienta HTTP jest obserwowany obiekt. Dzięki niemu zmiana zmiennej w bibliotece Angular 5 spowoduje automatyczne przejście do ekranu głównego aplikacji.

\begin{lstlisting}[caption=Metoda autoryzacji urządzenia mobilnego.]
public authenticate(
	login: string, 
	password: string): Observable<any> {
	const data = JSON.stringify({
		login,
		password
	});
	const headers = new HttpHeaders({ 
		'Content-Type': 'application/json' 
	});
	
	return this.http.post<any>(
		this.apiService.loginUrl,
		 data, { headers: headers })
	.map(response => {
		if (response && response.token) {
			localStorage.setItem('token', response.token);
		}
		return response;
	});
}
\end{lstlisting} 


\item \textbf{Wysłanie zdjęcia} - Użytkownik w celu uzyskania 


\end{itemize}
