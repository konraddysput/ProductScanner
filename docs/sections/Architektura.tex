\section{Podział projektu}
{Wykorzystanie wielu języków programowania (Java, C\#, Python, JavaScript, Android, TypeScript) wymagało podziału projektów ze względu użyte technologie oraz ich zastosowania w aplikacji. Miało to między innymi duży wpływ na szybszą fazę wytwarzania oprogramowania jak i łatwość w zrozumieniu kodu. Wykorzystanie innej koncepcji mogłoby spowodować bardzo wolne dzialanie środowiska programistycznego lub problemy z późniejszą naprawą błędów.Każda z aplikacji poprzez strukturę katalogową lub podprojektową wydzielała logiczne części podprojektu.	
		\begin{table}[htbp]
		\caption{Podział technologii}
		\label{sys-architecture}
		\begin{center}
			\begin{tabular}{ | p{4cm}| p{3cm} | p{6cm} |}
				\hline Nazwa podprojektu & Technologia &  Zastosowanie \\ \hline   
				\hline  Aplikacja mobilna &  Ionic - TypeScript & Aplikacja mobilna służąca do tworzenia oraz przesyłania zdjęć półek sklepowych oraz prezentację danych wynikowych.\\ \hline
				
				\hline  Mikroserwis przetwarzania obrazu & Python & Mikroserwis służący klasyfikacji obiektów występujących na obrazie oraz informacji o nich - pozycji, nazwie.\\ \hline
				
				\hline Mikroserwis zasad obiektów klasyfikacji  \mbox{bazodanowy} & Java & Mikroserwis służący do przetwarzania wyników otrzymanych z mikroserwisu analizy obrazu przy użyciu sieci semantycznej.\\ \hline
				
				\hline Aplikacja internetowa & ASP.NET Core & Aplikacja internetowa, odpowiedzialna za przetwarzanie żądań kierowanych z aplikacji mobilnych oraz zarządzanie przepływem danycb pomiędzy mikroserwisami.\\ \hline
			\end{tabular}
		\end{center}
	\end{table}	
	
	
Projekt zarządzający komunikacją pomiędzy aplikacją mobilną, a mikroserwisami wymagał dodatkowego użycia podmodułów. Wartwy aplikacji w tym przypadku tworzyły logiczną całość aplikacji internetowej oraz umożliwiały łatWość we wprowadzaniu nowych zmian lub zrozumieniu kodu przez innych.


\begin{table}[htbp]
	\caption{Podział technologii}
	\label{project-architecture}
	\begin{center}
		\begin{tabular}{ | p{3cm}| p{3cm} | p{6cm} |}
			\hline Nazwa modułu & Typ &  Opis \\ \hline   
			
			\hline  Moduł aplikacji internetowej REST \cite{REST} &  Aplikacja ASP.NET Core MVC & Moduł odpowiedzialny za przechwytywanie oraz przetwarzanie żądań HTTP kierowanych z aplikacji mobilnej. Jest to moduł uruchamiający pozostałe podmoduły oraz zawierający ich konfigurację.\\ \hline
			
			\hline  Moduł logiki biznesowej & Biblioteka klas & Moduł zawierający klasy odpowiedzialne za przetwarzanie danych odbieranych w punktach dostępowych aplikacji internetowych. \\ \hline
			
			\hline Moduł struktur bazodanowych  \mbox{bazodanowy} & Biblioteka klas & Moduł zawierający deklarację tabel bazodanowych oraz konfigurację bazy danych.\\ \hline
			
			\hline Moduł komunikacji & Biblioteka klas & Moduł zawierający konfigurację połączeń z pozostałymi mikroserwisami oraz modele komunikacji pomiędzy nimi.\\ \hline
			
			\hline Moduł modeli & Biblioteka klas & Moduł zawierający przetwarzane modele aplikacji.\\ \hline
			
			
			\hline Moduł konwersji danych & Biblioteka klas & Moduł zawierający logikę umożliwiających konwersję modeli przetwarzanych przez aplikację na modele bazodanowe lub komunikacyjne wykorzystywane przez Mikroserwisy\\ \hline

		\end{tabular}
	\end{center}
\end{table}	

W związku z podziałem projektu na podprojektu oraz podmoduły można wyróżnić rozbudowaną architekturę systemu oraz widoczny zakres obowiązków poszczególnych podprojektów. Zbiór poszczególnych podprojektów oraz opis ich architektury wraz z wykorzystaną technologią został dokładnie opisany w kolejnych podrozdziałach.}


\section{Komunikacja}
{Wykorzystanie wielu technologii oraz języków programowania uniemożliwiało skorzystanie ze wzorca projektowego zwanego monolitem. Zakładał on między innymi przepływ danych w obrębie jednej aplikacji, co w tym przypadku spowodowałoby duże problemy z obsługą błędów, przetwarzaniem wyników bibliotek oraz zwiększyło by znacząco czas wytwarzania oprogramowania. W związku z tym zdecydowano się na zastosowanie architektury mikroserwisów, w których każda z aplikacji stanowi osobny niezależny byt w hierarchi. W przypadku gdy jedna z aplikacji zostanie wyłączona lub napotka na nieoczekiwany błąd uniemożliwiający jej pracę, całość projektu może dalej przetwarzać dane, a użytkownik końcowy może nie dostrzec błędów. Wykorzystanie architektury mikroserwisów wymusza komunikację aplikacji przy pomocy wybranego protokołu komunikacyjnego, którym może być HTTP lub AMQP(Advanced Message Queuing Protocol)\cite{AMQP}. Jednym z priorytetów, stawianych podczas projektowania aplikacji, była szybkość przetwarzania danych. W związku z tym uznano, że protokół AMQP, który jest przystosowany do rozwiązań Internetu Rzeczy, umożliwi znacznie szybszą komunikację niż konieczność przetwarzania żądań HTTP. 
	
	
Rozwiązanie oparte o architekturę rozproszoną mikroserwisów pozwala nie tylko na wykorzystanie dowolnego języka programowania lub środowiska uruchomieniowego. Dzięki niemu możliwe jest zwiększenie mocy obliczeniowej dostępnej podczas przetwarzania danych w aplikacji poporzez wykorzystanie więcej niż jednej maszyny. W przypadku braku odpowiedniej ilości zasobów na jednym z komputerów, architektura zakłada możliwość podpięcia kolejnych agentów, które mogą przetwarzać dane oraz dostarczyć rezultat. W tym przypadku, każdy z nich musi połączyć się do jednego centralnego węzła komunikacyjnego tworzonego przez RabbitMQ \cite{RabbitMQ} - systemu kolejkowego.

Każdy z mikroserwisów korzysta z jednej zdefiniowanej kolejki, do której przesyłane są wiadomości wraz z danymi - product-scanner-api. Aby wiadomość trafiła do odpowiedniego mikroserwisu, wykorzystywany jest tak zwany routing-key, czyli wskazanie agentów, które nasłuchują w określonym celu. System oparty jest o konieczność potwierdzeń odebrania oraz przetworzenia danych przez pozostałe mikroserwisy. W przypadku napotkania awarii, system spróbuje co najmniej dwa razy ponownie wysłać wiadomość. Dane przesyłane pomiędzy serwisami są przekazywane w postaci bajtów, w których znajduje się plik formatu JSON \cite{JSON}. 
}
	
	
\section{Aplikacja internetowa - Gateway}	
{	Rozbicie architektury aplikacji internetowej na kilka podmodułów wymagało zastosowania odpowiednich wzorców projektowych oraz przemyślanej struktury aplikacji. Jednym z wzorców projektowych, który świetnie sprawdza się w tego typu przypadku aplikacjach jest wzorzec "odwróconego sterowania", znany pod nazwą "dependency injection". Umożliwia on między innymi na przekazywanie do konstruktorów klas, stworzonych wcześniej instancji obiektów. Umożliwiało to między innymi storzenie obiektu połączenia bazy danych, który mógł być używany w pozostałych projektach. Zastosowanie wzorca architektonicznego, umożliwiło zmniejszenie rendundancji kodu, która powstała by na skutek konieczności ciągłej inicjalizacji obiektów. Ponadto dobrą praktyką, do której powinien stosować się każdy programista, jest możliwość reużywalności kodu, na co z pewnością pozwala zastosowany wzorzec. 

Aplikacji mobilna w celu komunikacji używa protokołu HTTP. W związku z tym 	 przygotowano moduł umożliwiający przetwarzanie kierowanych żądań HTTP zgodnie z wzorcem architektonicznym REST(Representational State Transfer). Aplikacja internetowa zawiera bezstanowe kontrolery, które zkonwertują dane w postaci JSON wysłane z telefonu oraz przekażą je do dalszego przetwarzania przez aplikację. Wzorzec architektoczniczny zakłada między innymi sposób tworzenia adresów URL według dostępów do zasobów oraz zgodnie z metodą HTTP. Żądanie kierowane pod odpowiedni zasób, powoduje przekazanie zależności odpowiedniego punktu docelowego do konstruktora kontrolera przetwarzającego dane oraz przekazanie informacji do serwisu odpowiedzialnego za zasób. Odpowiedź kontrolera jest zależna od typu przesłanego zapytania. W przypadku utworzenia zasobów może być nią status kod 201 oznaczający pomyślnie stworzony zasób w systemie. Ze względu na bardzo istotną rolę jaką pełnią kontrolery w aplikacjach internetowych, ilość kodu znajdującego się w nich powinna być zmniejszona do minimum. Ich przeznaczeniem jest przyjęcie żądania oraz przekazanego do dalszego przetwarzania stąd nacisk na przeniesienie logiki biznesowej aplikacji do osobnego modułu.

Dalsze przetwarzanie danych aplikacji odbywa się w serwisach, czyli klasach odpowiedzialnych za przetwarzanie logiki biznesowej. Do ich odpowiedzialności należy między innymi może należeć zapis danych w bazie danych, lub przesłanie danych do mikroserwisów. Serwisy, tak samo jak i kontrolery, wykorzystując wzorzec odwróconego sterowania aby otrzymać niezbędne zależności konieczne do poprawnego przetworzenia danych. W celu zmniejszenia redundancji kodu wykorzystano typy generyczne oraz stworzono bazowe implementację serwisów. Zawiera ona kod, powtarzalny dla każdego serwisu - między innymi konwersję plików lub zapis danych w tabeli bazodanowej. 

Logika serwisu może zawierać wywołanie mikroserwisu w innej technologii. W tym przypadku pomyślne zapisanie w bazie danych może powodować zgłoszenie do mikroserwisu gotowości do możliwości przetwarzania obrazu lub informacji. W tym celu mechanizm odwróconego sterowania do konstruktora serwisu przekazuje obiekt komunikacji AMQP. Nazwa przekazanego obiekt do metody publikacji wiadomości przy użyciu mechanizmu refleksji umożliwia wskazanie pasma komunikacyjnego (routing-key), na który zostanie wysłana wiadomość. W przypadku otrzymania wiadomości zwrotnej, moduł zarządzania komunikacyją mikroserwisów posiada klasy odpowiadające za przechwytanie zdarzeń przesłanych do aplikacji. 

Komunikacja z aplikacją internetową przy pomocy protokołu REST nie jest umożliwia rozwiązania oczekiwania na przetworzone dane w przypadku zastosowania mikroserwisów. Architektura to umożliwia rozbicie aplikacji na wiele niezależnych podaplikacji, jednak nie umożliwia dostarczenia sprecyzowanej informacji, kiedy dane będą gotowe do dalszego przetwarzania. Zatem tworząc zasób, użytkownik w najgorszym przypadku nie otrzyma wszystkich danych, na których mu zależy. W związku z tym zasosowano komunikację przy użyciu gniazdek www oraz technologię SignalR \cite{SignalR}. Przechwycone zdarzenie umozliwia rozpowszechnienie do wszystkich klientów aplikacji informacji o nowych dancyh oraz możliwości ich wyświetlenia. Połączenie przy użyciu gniazdek wymaga, aby klient - aplikacja mobilna, łączył się do systemu wraz z początkiem korzystania z aplikacji. Umożliwia to komunikację w czasie rzeczywistym pomiędzy dowolną ilością urządzeń mobilnych a serwerem.
}

\section{Mikroserwis przetwarzania obrazu}

{ }
\\
\begin{center}
%	\makebox[\textwidth]{	\includegraphics[width=\paperwidth]{images/4.3 przeplyw danych}}
	\captionof{figure}{Diagram sekwencji tworzenia katalogu}

\end{center}
