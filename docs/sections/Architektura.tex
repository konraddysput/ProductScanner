\section{Podział projektu}
{Wykorzystanie wielu języków programowania (Java, C\#, Python, JavaScript, Android, TypeScript) wymagało podziału projektu ze względu na użyte technologie oraz ich zastosowania w aplikacji. Miało to między innymi duży wpływ na szybszą fazę wytwarzania oprogramowania, jak i łatwość w zrozumieniu kodu. Wykorzystanie innej koncepcji mogłoby spowodować bardzo wolne działanie środowiska programistycznego lub problemy z późniejszą naprawą błędów. Każda z aplikacji poprzez strukturę katalogową lub podprojektową wydzielała logiczne części podprojektu.	
		\begin{table}[htbp]
		\caption{Podział technologii}
		\label{sys-architecture}
		\begin{center}
			\begin{tabular}{ | p{4cm}| p{3cm} | p{6cm} |}
				\hline Nazwa podprojektu & Technologia &  Zastosowanie \\ \hline   
				\hline  Aplikacja mobilna &  Ionic - TypeScript & Aplikacja mobilna służąca do tworzenia oraz przesyłania zdjęć półek sklepowych oraz prezentację danych wynikowych.\\ \hline
				
				\hline  Mikroserwis przetwarzania obrazu & Python & Mikroserwis służący do klasyfikacji obiektów występujących na obrazie oraz informacji o nich - pozycji, nazwie.\\ \hline
				
				\hline Mikroserwis zasad obiektów klasyfikacji  \mbox{bazodanowy} & Java & Mikroserwis służący do przetwarzania wyników otrzymanych z mikroserwisu analizy obrazu przy użyciu sieci semantycznej.\\ \hline
				
				\hline Aplikacja internetowa & ASP.NET Core & Aplikacja internetowa odpowiedzialna za przetwarzanie żądań kierowanych z aplikacji mobilnych oraz zarządzanie przepływem danych pomiędzy mikroserwisami.\\ \hline
			\end{tabular}
		\end{center}
	\end{table}	
	
	
Projekt zarządzający komunikacją pomiędzy aplikacją mobilną a mikroserwisami wymagał dodatkowego użycia podmodułów. Warstwy aplikacji w tym przypadku tworzyły logiczną całość aplikacji internetowej oraz ułatwiały wprowadzanie nowych zmian lub zrozumienie kodu przez innych.


\begin{table}[htbp]
	\caption{Podział technologii}
	\label{project-architecture}
	\begin{center}
		\begin{tabular}{ | p{3cm}| p{3cm} | p{6cm} |}
			\hline Nazwa modułu & Typ &  Opis \\ \hline   
			
			\hline  Moduł aplikacji internetowej REST &  Aplikacja ASP.NET Core MVC & Moduł odpowiedzialny za przechwytywanie oraz przetwarzanie żądań HTTP kierowanych z aplikacji mobilnej. Jest to moduł uruchamiający pozostałe podmoduły oraz zawierający ich konfigurację.\\ \hline
			
			\hline  Moduł logiki biznesowej & Biblioteka klas & Moduł zawierający klasy odpowiedzialne za przetwarzanie danych odbieranych w punktach dostępowych aplikacji internetowych. \\ \hline
			
			\hline Moduł struktur bazodanowych  \mbox{bazodanowy} & Biblioteka klas & Moduł zawierający deklarację tabel bazodanowych oraz konfigurację bazy danych.\\ \hline
			
			\hline Moduł komunikacji & Biblioteka klas & Moduł zawierający konfigurację połączeń z pozostałymi mikroserwisami oraz modele komunikacji pomiędzy nimi.\\ \hline
			
			\hline Moduł modeli & Biblioteka klas & Moduł zawierający przetwarzane modele aplikacji.\\ \hline
			
			
			\hline Moduł konwersji danych & Biblioteka klas & Moduł zawierający logikę umożliwiającą konwersję modeli przetwarzanych przez aplikację na modele bazodanowe lub komunikacyjne wykorzystywane przez Mikroserwisy\\ \hline

		\end{tabular}
	\end{center}
\end{table}	

W związku z podziałem projektu na podprojekty oraz podmoduły można wyróżnić rozbudowaną architekturę systemu oraz widoczny zakres obowiązków poszczególnych podprojektów. Zbiór poszczególnych podprojektów oraz opis ich architektury wraz z wykorzystaną technologią został dokładnie opisany w kolejnych podrozdziałach.}


\section{Komunikacja}
{Wykorzystanie wielu technologii oraz języków programowania uniemożliwiało użycie wzorca projektowego zwanego monolitem. Zakładał on między innymi przepływ danych w obrębie jednej aplikacji, co w tym przypadku spowodowałoby duże problemy z obsługą błędów, przetwarzaniem wyników bibliotek oraz zwiększyłoby znacząco czas wytwarzania oprogramowania. W związku z tym zdecydowano się na zastosowanie architektury mikroserwisów, w których każda z aplikacji stanowi osobny niezależny byt w hierarchii. W przypadku gdy jedna z aplikacji zostanie wyłączona lub napotka na nieoczekiwany błąd uniemożliwiający jej pracę, całość projektu może dalej przetwarzać dane, a użytkownik końcowy może nie dostrzec błędów. Wykorzystanie architektury mikroserwisów wymusza komunikację aplikacji przy pomocy wybranego protokołu komunikacyjnego, którym może być HTTP lub AMQP(Advanced Message Queuing Protocol)\cite{AMQP}. Jednym z priorytetów stawianych podczas projektowania aplikacji była szybkość przetwarzania danych. W związku z tym uznano, że protokół AMQP, który jest przystosowany do rozwiązań Internetu Rzeczy, umożliwi znacznie szybszą komunikację niż konieczność przetwarzania żądań HTTP. 
	
	
Rozwiązanie oparte o architekturę rozproszoną mikroserwisów pozwala nie tylko na wykorzystanie dowolnego języka programowania lub środowiska uruchomieniowego. Dzięki niemu możliwe jest zwiększenie mocy obliczeniowej dostępnej podczas przetwarzania danych w aplikacji poprzez wykorzystanie więcej niż jednej maszyny. W przypadku braku odpowiedniej ilości zasobów na jednym z komputerów architektura zakłada możliwość podpięcia kolejnych agentów, które mogą przetwarzać dane oraz dostarczyć rezultat. W tym przypadku, każdy z nich musi połączyć się do jednego centralnego węzła komunikacyjnego tworzonego przez RabbitMQ \cite{RabbitMQ} - systemu kolejkowego.

Każdy z mikroserwisów korzysta z jednej zdefiniowanej kolejki, do której przesyłane są wiadomości wraz z danymi - product-scanner-api. Aby wiadomość trafiła do odpowiedniego mikroserwisu, wykorzystywany jest tak zwany routing-key, czyli wskazanie agentów, które nasłuchują w określonym celu. System oparty jest o konieczność potwierdzeń odebrania oraz przetworzenia danych przez pozostałe mikroserwisy. W przypadku napotkania awarii system spróbuje co najmniej dwa razy ponownie wysłać wiadomość. Dane przesyłane pomiędzy serwisami są przekazywane w postaci bajtów, w których znajduje się plik formatu JSON \cite{JSON}. 
}
	
	
\section{Aplikacja internetowa - Gateway}	
{	Rozbicie architektury aplikacji internetowej na kilka podmodułów wymagało zastosowania odpowiednich wzorców projektowych oraz przemyślanej struktury aplikacji. Jednym ze wzorców projektowych, który świetnie sprawdza się w tego typu aplikacjach, jest wzorzec "odwróconego sterowania", znany pod nazwą "dependency injection". Umożliwia on między innymi przekazywanie do konstruktorów klas stworzonych wcześniej instancji obiektów. Umożliwiało to między innymi stworzenie obiektu połączenia bazy danych, który mógł być używany w pozostałych projektach. Zastosowanie wzorca architektonicznego umożliwiło zmniejszenie rendundancji kodu, która powstała na skutek konieczności ciągłej inicjalizacji obiektów. Ponadto dobrą praktyką, do której powinien stosować się każdy programista, jest możliwość reużywalności kodu, na co z pewnością pozwala zastosowany wzorzec. 

Aplikacja mobilna w celu komunikacji używa protokołu HTTP. W związku z tym 	 przygotowano moduł umożliwiający przetwarzanie kierowanych żądań HTTP zgodnie ze wzorcem architektonicznym REST(Representational State Transfer). Aplikacja internetowa zawiera bezstanowe kontrolery, które konwertują dane wysłane z telefonu w postaci JSON oraz przekazują je do dalszego przetwarzania przez aplikację. Wzorzec architektoniczny zakłada między innymi sposób tworzenia adresów URL według dostępów do zasobów oraz zgodnie z metodą HTTP. Żądanie kierowane pod odpowiedni zasób powoduje przekazanie zależności odpowiedniego punktu docelowego do konstruktora kontrolera przetwarzającego dane oraz przekazanie informacji do serwisu odpowiedzialnego za zasób. Odpowiedź kontrolera jest zależna od typu przesłanego zapytania. W przypadku utworzenia zasobów może być nią status kod 201 oznaczający pomyślnie stworzony zasób w systemie. Ze względu na bardzo istotną rolę jaką pełnią kontrolery w aplikacjach internetowych, ilość kodu znajdującego się w nich powinna być zmniejszona do minimum. Ich przeznaczeniem jest przyjęcie żądania oraz przekazanie do dalszego przetwarzania, stąd nacisk na przeniesienie logiki biznesowej aplikacji do osobnego modułu.

Dalsze przetwarzanie danych aplikacji odbywa się w serwisach, czyli klasach odpowiedzialnych za przetwarzanie logiki biznesowej. Do ich odpowiedzialności należy między innymi zapis danych w bazie danych lub przesłanie danych do mikroserwisów. Serwisy, tak samo jak i kontrolery, wykorzystują wzorzec odwróconego sterowania, aby otrzymać niezbędne zależności konieczne do poprawnego przetworzenia danych. W celu zmniejszenia redundancji kodu wykorzystano typy generyczne oraz stworzono bazowe implementacje serwisów. Zawiera ona kod, powtarzalny dla każdego serwisu - między innymi konwersję plików lub zapis danych w tabeli bazodanowej. 

Logika serwisu może zawierać wywołanie mikroserwisu w innej technologii. W tym przypadku pomyślne zapisanie w bazie danych może powodować zgłoszenie do mikroserwisu gotowości do możliwości przetwarzania obrazu lub informacji. W tym celu mechanizm odwróconego sterowania do konstruktora serwisu przekazuje obiekt komunikacji AMQP. Nazwa przekazanego obiektu do metody publikacji wiadomości przy użyciu mechanizmu refleksji umożliwia wskazanie pasma komunikacyjnego (routing-key), na który zostanie wysłana wiadomość. W przypadku otrzymania wiadomości zwrotnej moduł zarządzania komunikacją mikroserwisów posiada klasy odpowiadające za przechwytywanie zdarzeń przesłanych do aplikacji. 

Komunikacja z aplikacją internetową przy pomocy architektury REST nie umożliwia wymiany danych w czasie rzeczywistym. Dodatkowo wykorzystanie mikroserwisów umożliwia rozbicie aplikacji na wiele niezależnych podaplikacji, jednak nie pozwala na predykcję czasu przetworzenia danych. Tworząc zasób, użytkownik w najgorszym przypadku nie otrzyma wszystkich danych, na których mu zależy w trakcie pierwszego dostępu do widoku. W związku z tym zastosowano komunikację przy użyciu gniazdek www oraz technologię SignalR \cite{SignalR}. Przechwycone zdarzenie pozwala na rozpowszechnienie danych do wszystkich klientów podłączonych do aplikacji. Połączenie te wymaga, aby klient - aplikacja mobilna, łączył się do systemu wraz z początkiem korzystania z aplikacji. Wykorzystanie technologii gniazdek pozwala na dodatkowe rozproszenie komunikacji oraz obsługę żądań wielu użytkowników w tym samym czasie.
%sprawdzone /\

\section{Aplikacja mobilna}
{ Użytkownicy systemu dostarczają zdjęcia poddawane przetwarzaniu przy użyciu aplikacji mobilnej. Tworząc rozwiązanie działające na telefony komórkowe, należy uwzględnić różne platformy oraz architektury urządzeń. Ze względu na wykorzystanie aplikacji do prezentacji danych oraz przesyłanie zdjęć z galerii skorzystano z rozwiązania hybrydowego, kosztem rozwiazania natywnego. Wiąże się to z brakiem dostępu bezpośrednio do bibliotek, które współpracują bezpośrednio z podzespołami urządzenia, lecz przyspiesza w znaczący sposób wytwarzanie oprogramowania na wiele platform. Aplikacja może działać na systemach operacyjnych iOS oraz Android. Stworzono ją przy użyciu bibliotek Ionic \cite{Ionic}, który bazuje na modelu Cordova \cite{Cordova}. W celu prezentacji danych skorzystano z biblioteki Angular\cite{Angular} w wersji 5. 
	
Aplikacja mobilna przygotowuje widoki w oparciu o dane dostępne w serwerze. Komunikacja z serwerem odbywa się przy użyciu protokołu HTTP z REST API aplikacji intenretowej. Urządzenia mobilne podłączone do siecii, posiadają swoją własną sieciową oraz adres IP różny od używanego przez serwer. Spowodowało to konieczność odblokowania połączeń do serwera z innych domen, niż ta używana przez aplikację internetową. W związku z tym na serwerze www uruchomiono obsługę CORS \cite{CORS} (Cross-Origin Resource Sharing) co pozwoliło na komunikację HTTP. 

Tworzenie aplikacji mobilnej przy użyciu biblioteki Angular wymusza na programiście znajomość oraz stosowanie wzorców projektowych takich jak reaktynwe programowanie. Dzięki temu zmiana wartości zmiennych klas przypisanych do komponentów drzewie DOM spowoduje zmianę danych wyświetlanych użytkownikowi. Proces wiązania danych poprzez zastosowanie typów obserwowanych może być uciążliwy dla programistów przyzwyczajonych do operacji asynchronicznych używanych na platformach uruchomieniowych .NET lub NodeJS. 
}
\section{Mikroserwis przetwarzania obrazu}
{
}

\section{Mikroserwis reguł semantycznych}

%\begin{center}
%	\makebox[\textwidth]{	\includegraphics[width=\paperwidth]{images/4.3 przeplyw danych}}
%	\captionof{figure}{Diagram sekwencji tworzenia katalogu}
%\end{center}
